use btleplug::api::{Central, Characteristic, Manager as _, Peripheral as _, ScanFilter, WriteType};

use btleplug::platform::{Manager, Peripheral};

use tokio::io::{self, AsyncBufReadExt, BufReader};
use std::io::Write;

use tokio::sync::mpsc;

use tokio::time::{self, Duration};

use uuid::Uuid;

use futures::stream::StreamExt;

use std::collections::{HashMap, HashSet};

use std::convert::TryInto;

use std::sync::{Arc, Mutex};

use std::time::SystemTime;

use std::env;

use bloomfilter::Bloom;

// use ed25519_dalek::SigningKey; // Removed: unused

// use x25519_dalek::StaticSecret; // Removed: unused

// use rand::rngs::OsRng; // Removed: unused
use rand::Rng;
use sha2::{Sha256, Digest};
use serde_json;

mod compression;
mod fragmentation;
mod encryption;
mod terminal_ux;
mod persistence;
mod data_structures;
mod payload_handling;
mod packet_parser;
mod packet_creation;

use compression::decompress;
use fragmentation::{send_packet_with_fragmentation, should_fragment};
use encryption::EncryptionService;
use terminal_ux::{ChatContext, ChatMode, format_message_display, print_help};
use persistence::{AppState, load_state, save_state, encrypt_password, decrypt_password};
use payload_handling::{
    unpad_message, parse_bitchat_message_payload, create_bitchat_message_payload,
    create_bitchat_message_payload_full, create_encrypted_channel_message_payload
};
use packet_parser::{parse_bitchat_packet, generate_keys_and_payload};
use packet_creation::{
    create_bitchat_packet, create_bitchat_packet_with_signature,
    create_bitchat_packet_with_recipient_and_signature, create_bitchat_packet_with_recipient
};

use crate::data_structures::{
    DebugLevel, DEBUG_LEVEL, MessageType, Peer, BitchatPacket, DeliveryAck,
    DeliveryTracker, FragmentCollector, VERSION, BITCHAT_SERVICE_UUID, BITCHAT_CHARACTERISTIC_UUID,
    COVER_TRAFFIC_PREFIX, FLAG_HAS_RECIPIENT, FLAG_HAS_SIGNATURE, FLAG_IS_COMPRESSED,
    BROADCAST_RECIPIENT,
};

// Function to handle input and display ASCII art
fn spawn_input_handler(tx: mpsc::Sender<String>) -> tokio::task::JoinHandle<()> {
    tokio::spawn(async move {
        let mut stdin = BufReader::new(io::stdin()).lines();

        // Display ASCII art logo in Matrix green
        println!("\n\x1b[38;5;46m##\\       ##\\   ##\\               ##\\                  ##\\");
        println!("## |      \\__|  ## |              ## |                 ## |");
        println!("#######\\  ##\\ ######\\    #######\\ #######\\   ######\\ ######\\");
        println!("##  __##\\ ## |\\_##  _|  ##  _____|##  __##\\  \\____##\\\\_##  _|");
        println!("## |  ## |## |  ## |    ## /      ## |  ## | ####### | ## |");
        println!("## |  ## |## |  ## |##\\ ## |      ## |  ## |##  __## | ## |##\\");
        println!("#######  |## |  \\####  |\\#######\\ ## |  ## |\\####### | \\####  |");
        println!("\\_______/ \\__|   \\____/  \\_______|\\__|  \\__| \\_______|  \\____/\x1b[0m");
        println!("\n\x1b[38;5;40m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\x1b[0m");
        println!("\x1b[37mDecentralized ‚Ä¢ Encrypted ‚Ä¢ Peer-to-Peer ‚Ä¢ Open Source\x1b[0m");
        println!("\x1b[37m                bitch@ the terminal {}\x1b[0m", VERSION);
        println!("\x1b[38;5;40m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\x1b[0m\n");

        loop {
            // Note: We can't access chat_context here directly, but we'll improve this later
            print!("> ");
            use std::io::{self as stdio, Write};
            let _ = stdio::stdout().flush();

            if let Ok(Some(line)) = stdin.next_line().await {
                if tx.send(line).await.is_err() { break; }
            } else { break; }
        }
    })
        }

// Function to handle Bluetooth setup and connection
async fn setup_bluetooth_connection() -> Result<Peripheral, Box<dyn std::error::Error>> {
    let manager = Manager::new().await?;
    let adapters = manager.adapters().await?;
    let adapter = match adapters.into_iter().nth(0) {
        Some(adapter) => adapter,
        None => {
            println!("\n\x1b[91m‚ùå No Bluetooth adapter found\x1b[0m");
            println!("\x1b[90mPlease check:\x1b[0m");
            println!("\x1b[90m  ‚Ä¢ Your device has Bluetooth hardware\x1b[0m");
            println!("\x1b[90m  ‚Ä¢ Bluetooth is enabled in system settings\x1b[0m");
            println!("\x1b[90m  ‚Ä¢ You have permission to use Bluetooth\x1b[0m");
            return Err("No Bluetooth adapter found.".into());
        }
    };

    adapter.start_scan(ScanFilter::default()).await?;

    println!("\x1b[90m¬ª Scanning for bitchat service...\x1b[0m");
    debug_println!("[1] Scanning for bitchat service...");

    let peripheral = loop {
        if let Some(p) = find_peripheral(&adapter).await? {
            println!("\x1b[90m¬ª Found bitchat service! Connecting...\x1b[0m");
            debug_println!("[1] Match Found! Connecting...");

            adapter.stop_scan().await?;

            break p;
        }

        time::sleep(Duration::from_secs(1)).await;
    };

    if let Err(e) = peripheral.connect().await {
        println!("\n\x1b[91m‚ùå Connection failed\x1b[0m");
        println!("\x1b[90mReason: {}\x1b[0m", e);
        println!("\x1b[90mPlease check:\x1b[0m");
        println!("\x1b[90m  ‚Ä¢ Bluetooth is enabled\x1b[0m");
        println!("\x1b[90m  ‚Ä¢ The other device is running BitChat\x1b[0m");
        println!("\x1b[90m  ‚Ä¢ You're within range\x1b[0m");
        println!("\n\x1b[90mTry running the command again.\x1b[0m");
        return Err(format!("Connection failed: {}", e).into());
    }

    Ok(peripheral)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Parse command line arguments
    let args: Vec<String> = env::args().collect();
    
    // Check for debug flags
    unsafe {
        if args.iter().any(|arg| arg == "-dd" || arg == "--debug-full") {
            DEBUG_LEVEL = DebugLevel::Full;
            println!("üêõ Debug mode: FULL (verbose output)");
        } else if args.iter().any(|arg| arg == "-d" || arg == "--debug") {
            DEBUG_LEVEL = DebugLevel::Basic;
            println!("üêõ Debug mode: BASIC (connection info)");
        }
        // Otherwise stays at Clean (default)
    }

    let (tx, mut rx) = mpsc::channel::<String>(10);

    let _input_handle = spawn_input_handler(tx);

    let peripheral = setup_bluetooth_connection().await?;

    peripheral.discover_services().await?;

    let characteristics = peripheral.characteristics();

    let cmd_char = characteristics.iter().find(|c| c.uuid == BITCHAT_CHARACTERISTIC_UUID).expect("Characteristic not found.");

    peripheral.subscribe(cmd_char).await?;

    let mut notification_stream = peripheral.notifications().await?;

    debug_println!("[2] Connection established.");
    
    // TODO: Implement MTU negotiation
    // Swift calls: peripheral.maximumWriteValueLength(for: .withoutResponse)
    // Default BLE MTU is 23 bytes (20 data), extended can be up to 512


    debug_println!("[3] Performing handshake...");

    // Generate peer ID like Swift does (4 random bytes as hex)
    let mut peer_id_bytes = [0u8; 4];
    rand::thread_rng().fill(&mut peer_id_bytes);
    let my_peer_id = hex::encode(&peer_id_bytes);
    debug_full_println!("[DEBUG] My peer ID: {}", my_peer_id);
    
    // Load persisted state early to get saved nickname
    let mut app_state = load_state();
    let mut nickname = app_state.nickname.clone().unwrap_or_else(|| "my-rust-client".to_string());

    // Create encryption service
    let encryption_service = Arc::new(EncryptionService::new());
    let (key_exchange_payload, _) = generate_keys_and_payload(&encryption_service);

    let key_exchange_packet = create_bitchat_packet(&my_peer_id, MessageType::KeyExchange, key_exchange_payload);

    peripheral.write(cmd_char, &key_exchange_packet, WriteType::WithoutResponse).await?;

    // Add delay between key exchange and announce to ensure Android processes them properly
    time::sleep(Duration::from_millis(500)).await;

    let announce_packet = create_bitchat_packet(&my_peer_id, MessageType::Announce, nickname.as_bytes().to_vec());

    peripheral.write(cmd_char, &announce_packet, WriteType::WithoutResponse).await?;

    debug_println!("[3] Handshake sent. You can now chat.");
    if app_state.nickname.is_some() {
        println!("\x1b[90m¬ª Using saved nickname: {}\x1b[0m", nickname);
    }
    println!("\x1b[90m¬ª Type /status to see connection info\x1b[0m");


    let peers: Arc<Mutex<HashMap<String, Peer>>> = Arc::new(Mutex::new(HashMap::new()));

    let mut bloom = Bloom::new_for_fp_rate(500, 0.01);

    let mut fragment_collector = FragmentCollector::new();
    let mut delivery_tracker = DeliveryTracker::new();

    let mut chat_context = ChatContext::new();
    let mut channel_keys: HashMap<String, [u8; 32]> = HashMap::new();
    let mut _chat_messages: HashMap<String, Vec<String>> = HashMap::new();  // for /clear command - stores messages by context
    
    // Already loaded app_state above for nickname
    let mut blocked_peers = app_state.blocked_peers.clone();
    let mut channel_creators = app_state.channel_creators.clone();
    let mut password_protected_channels = app_state.password_protected_channels.clone();
    let mut channel_key_commitments = app_state.channel_key_commitments.clone();
    let mut discovered_channels: HashSet<String> = HashSet::new();  // Track all discovered channels
    
    // Auto-restore channel keys from saved passwords (matching iOS behavior)
    if let Some(identity_key) = &app_state.identity_key {
        for (channel, encrypted_password) in &app_state.encrypted_channel_passwords {
            match decrypt_password(encrypted_password, identity_key) {
                Ok(password) => {
                    let key = EncryptionService::derive_channel_key(&password, channel);
                    channel_keys.insert(channel.clone(), key);
                    debug_println!("[CHANNEL] Restored key for password-protected channel: {}", channel);
                }
                Err(e) => {
                    debug_println!("[CHANNEL] Failed to restore key for {}: {}", channel, e);
                }
            }
        }
    }
    // Note: We don't restore joined_channels as they need to be re-joined via announce
    
    // Clone fields that will be used in the closure to avoid borrow checker issues
    let favorites = app_state.favorites.clone();
    let identity_key = app_state.identity_key.clone();
    
    // Helper to create AppState for saving
    let create_app_state = |blocked: &HashSet<String>, 
                           creators: &HashMap<String, String>,
                           channels: &Vec<String>,
                           protected: &HashSet<String>,
                           commitments: &HashMap<String, String>,
                           encrypted_passwords: &HashMap<String, persistence::EncryptedPassword>,
                           current_nickname: &str| -> AppState {
        AppState {
            nickname: Some(current_nickname.to_string()),
            blocked_peers: blocked.clone(),
            channel_creators: creators.clone(),
            joined_channels: channels.clone(),
            password_protected_channels: protected.clone(),
            channel_key_commitments: commitments.clone(),
            favorites: favorites.clone(),
            identity_key: identity_key.clone(),
            encrypted_channel_passwords: encrypted_passwords.clone(),
        }
    };


    loop {

        tokio::select! {

            Some(line) = rx.recv() => {

                if handle_number_switching(&line, &mut chat_context) {
                    continue;
                }
                if handle_help_command(&line) {
                    continue;
                }
                if handle_list_command(&line, &mut chat_context) {
                    continue;
                }
                if handle_name_command(
                    &line,
                    &mut nickname,
                    &my_peer_id,
                    &peripheral,
                    cmd_char,
                    &blocked_peers,
                    &channel_creators,
                    &chat_context,
                    &password_protected_channels,
                    &channel_key_commitments,
                    &app_state,
                    &create_app_state,
                ).await {
                    continue;
                }

                // Handle /j command
                if handle_join_command(
                    &line,
                    &password_protected_channels,
                    &mut channel_keys,
                    &mut discovered_channels,
                    &mut chat_context,
                    &channel_key_commitments,
                    &mut app_state,
                    &create_app_state,
                    &nickname,
                    &peripheral,
                    cmd_char,
                    &channel_creators,
                ).await {
                    continue;
                }

                if handle_exit_command(
                    &line,
                    &blocked_peers,
                    &channel_creators,
                    &chat_context,
                    &password_protected_channels,
                    &channel_key_commitments,
                    &app_state,
                    &create_app_state,
                    &nickname,
                ) {
                    break;
                }
                
                // Handle /reply command
                if handle_reply_command(&line, &mut chat_context) {
                    continue;
                }
                
                // Handle /public command
                if handle_public_command(&line, &mut chat_context) {
                    continue;
                }
                
                // Handle /online command
                if handle_online_command(&line, &peers) {
                    continue;
                }
                
                // Handle /channels command
                if handle_channels_command(&line, &chat_context, &channel_keys, &password_protected_channels) {
                    continue;
                }
                
                // Handle private messages
                if handle_dm_command(
                    &line,
                    &mut chat_context,
                    &peers,
                    &nickname,
                    &my_peer_id,
                    &mut delivery_tracker,
                    &encryption_service,
                    &peripheral,
                    cmd_char,
                ).await {
                    continue;
                }

                // NOTE: DM mode handling removed from here - moved after command checks to allow commands in DM mode
                
                // Handle /block command
                if handle_block_command(
                    &line,
                    &mut blocked_peers,
                    &peers,
                    &encryption_service,
                    &channel_creators,
                    &chat_context,
                    &password_protected_channels,
                    &channel_key_commitments,
                    &app_state,
                    &create_app_state,
                    &nickname,
                ) {
                    continue;
                }
                
                // Handle /unblock command
                if handle_unblock_command(
                    &line,
                    &mut blocked_peers,
                    &peers,
                    &encryption_service,
                    &channel_creators,
                    &chat_context,
                    &password_protected_channels,
                    &channel_key_commitments,
                    &app_state,
                    &create_app_state,
                    &nickname,
                ) {
                    continue;
                }
                
                // Handle /clear command
                if handle_clear_command(&line, &chat_context) {
                    continue;
                }
                
                // Handle /channels command
                if handle_channels_command(&line, &chat_context, &channel_keys, &password_protected_channels) {
                    continue;
                }
                
                // Handle /status command
                if handle_status_command(&line, &peers, &chat_context, &nickname, &my_peer_id) {
                    continue;
                }
                
                // Handle /leave command
                if handle_leave_command(
                    &line,
                    &mut chat_context,
                    &mut channel_keys,
                    &mut password_protected_channels,
                    &mut channel_creators,
                    &mut channel_key_commitments,
                    &mut app_state,
                    &blocked_peers,
                    &create_app_state,
                    &nickname,
                    &my_peer_id,
                    &peripheral,
                    cmd_char,
                ).await {
                    continue;
                }
                
                // Handle /pass command
                if handle_pass_command(
                    &line,
                    &chat_context,
                    &mut channel_creators,
                    &mut channel_keys,
                    &mut password_protected_channels,
                    &mut channel_key_commitments,
                    &mut app_state,
                    &blocked_peers,
                    &create_app_state,
                    &nickname,
                    &my_peer_id,
                    &encryption_service,
                    &peripheral,
                    cmd_char,
                ).await {
                    continue;
                }
                
                // Handle /transfer command
                if handle_transfer_command(
                    &line,
                    &chat_context,
                    &mut channel_creators,
                    &password_protected_channels,
                    &channel_keys,
                    &blocked_peers,
                    &create_app_state,
                    &nickname,
                    &my_peer_id,
                    &peers,
                    &peripheral,
                    cmd_char,
                ).await {
                    continue;
                }
                
                // Check for unknown commands
                if line.starts_with("/") {
                    println!("\x1b[93m‚ö† Unknown command: {}\x1b[0m", line.split_whitespace().next().unwrap_or(""));
                    println!("\x1b[90mType /help to see available commands.\x1b[0m");
                    continue;
                }
                
                // Check if in DM mode first
                if let ChatMode::PrivateDM { nickname: target_nickname, peer_id: target_peer_id } = &chat_context.current_mode {
                    handle_private_dm_message(
                        &line,
                        &nickname,
                        &my_peer_id,
                        target_nickname,
                        target_peer_id,
                        &mut delivery_tracker,
                        &encryption_service,
                        &peripheral,
                        cmd_char,
                        &chat_context,
                    ).await;
                    continue;
                }
                
                // Regular public/channel message
                handle_regular_message(
                    &line,
                    &nickname,
                    &my_peer_id,
                    &chat_context,
                    &password_protected_channels,
                    &mut channel_keys,
                    &encryption_service,
                    &mut delivery_tracker,
                    &peripheral,
                    cmd_char,
                ).await;

            },

            Some(notification) = notification_stream.next() => {
                // Simple packet logging
                if notification.value.len() >= 2 {
                    let msg_type = notification.value[1];
                    debug_full_println!("[PACKET] Received {} bytes, type: 0x{:02X}", notification.value.len(), msg_type);
                }
                
                match parse_bitchat_packet(&notification.value) {
                    Ok(packet) => {
                        // Ignore our own messages
                        if packet.sender_id_str == my_peer_id {
                            continue;
                        }

                        let mut peers_lock = peers.lock().unwrap();

                     match packet.msg_type {

                         MessageType::Announce => {
                             handle_announce_message(&packet, &mut peers_lock);

                         },

                         MessageType::Message => {
                             handle_message_packet(
                                 &packet,
                                 &notification.value,
                                 &mut peers_lock,
                                 &mut bloom,
                                 &mut discovered_channels,
                                 &mut password_protected_channels,
                                 &mut channel_keys,
                                 &mut chat_context,
                                 &mut delivery_tracker,
                                 &encryption_service,
                                 &peripheral,
                                 cmd_char,
                                 &nickname,
                                 &my_peer_id,
                                 &blocked_peers,
                             ).await;

                         },
                         MessageType::FragmentStart | MessageType::FragmentContinue | MessageType::FragmentEnd => {
                             handle_fragment_packet(
                                 &packet,
                                 &notification.value,
                                 &mut fragment_collector,
                                 &mut peers_lock,
                                 &mut bloom,
                                 &mut discovered_channels,
                                 &mut password_protected_channels,
                                 &mut chat_context,
                                 &encryption_service,
                                 &peripheral,
                                 cmd_char,
                                 &nickname,
                                 &my_peer_id,
                                 &blocked_peers,
                             ).await;
                         },
                         MessageType::KeyExchange => {
                             handle_key_exchange_message(
                                 &packet,
                                 &mut peers_lock,
                                 &encryption_service,
                                 &peripheral,
                                 cmd_char,
                                 &my_peer_id,
                             ).await;
                         },
                         MessageType::Leave => {
                             handle_leave_message(
                                 &packet,
                                 &mut peers_lock,
                                 &chat_context,
                             );
                         },
                         
                         MessageType::ChannelAnnounce => {
                             handle_channel_announce_message(
                                 &packet,
                                 &mut channel_creators,
                                 &mut password_protected_channels,
                                 &mut channel_keys,
                                 &mut channel_key_commitments,
                                 &mut chat_context,
                                 &blocked_peers,
                                 &app_state.encrypted_channel_passwords,
                                 &nickname,
                                 &create_app_state,
                             );
                         },

                         MessageType::DeliveryAck => {
                             handle_delivery_ack_message(
                                 &packet,
                                 &notification.value,
                                 &encryption_service,
                                 &mut delivery_tracker,
                                 &peripheral,
                                 cmd_char,
                                 &my_peer_id,
                             ).await;
                         },
                        
                        MessageType::DeliveryStatusRequest => {
                            handle_delivery_status_request_message(&packet);
                        },
                        
                        MessageType::ReadReceipt => {
                            handle_read_receipt_message(&packet);
                        },
                        
                        _ => {}

                     }
                    },
                    Err(_e) => {
                        // Silently ignore unparseable packets (following working example)
                    }
                }
            },

             _ = tokio::signal::ctrl_c() => { break; }

        }

    }


    debug_println!("\n[+] Disconnecting...");

    Ok(())

}


async fn find_peripheral(adapter: &btleplug::platform::Adapter) -> Result<Option<Peripheral>, btleplug::Error> {

    for p in adapter.peripherals().await? {

        if let Ok(Some(properties)) = p.properties().await {

            if properties.services.contains(&BITCHAT_SERVICE_UUID) { return Ok(Some(p)); }

        }

    }

    Ok(None)

}





#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_type_values() {
        // Verify MessageType enum values match the protocol specification
        // This ensures compatibility with Swift and Android implementations
        assert_eq!(MessageType::Announce as u8, 0x01);
        assert_eq!(MessageType::KeyExchange as u8, 0x02);
        assert_eq!(MessageType::Leave as u8, 0x03);
        assert_eq!(MessageType::Message as u8, 0x04);
        assert_eq!(MessageType::FragmentStart as u8, 0x05);
        assert_eq!(MessageType::FragmentContinue as u8, 0x06);
        assert_eq!(MessageType::FragmentEnd as u8, 0x07);
        assert_eq!(MessageType::ChannelAnnounce as u8, 0x08);
        assert_eq!(MessageType::ChannelRetention as u8, 0x09);
        assert_eq!(MessageType::DeliveryAck as u8, 0x0A);
        assert_eq!(MessageType::DeliveryStatusRequest as u8, 0x0B);
        assert_eq!(MessageType::ReadReceipt as u8, 0x0C);
    }

    #[test]
    fn test_protocol_constants() {
        // Verify protocol constants match Swift/Android implementations
        assert_eq!(FLAG_HAS_RECIPIENT, 0x01);
        assert_eq!(FLAG_HAS_SIGNATURE, 0x02);
        assert_eq!(FLAG_IS_COMPRESSED, 0x04);
        assert_eq!(FLAG_HAS_CHANNEL, 0x40);
        assert_eq!(SIGNATURE_SIZE, 64);
        assert_eq!(BROADCAST_RECIPIENT, [0xFF; 8]);
    }
} 

fn handle_number_switching(line: &str, chat_context: &mut ChatContext) -> bool {
    if line.len() == 1 {
        if let Ok(num) = line.parse::<usize>() {
            if chat_context.switch_to_number(num) {
                debug_println!("{}", chat_context.get_status_line());
            } else {
                println!("¬ª Invalid conversation number");
            }
            return true;
        }
    }
    false
}

fn handle_help_command(line: &str) -> bool {
    if line == "/help" {
        print_help();
        return true;
    }
    false
}

async fn handle_name_command(
    line: &str,
    nickname: &mut String,
    my_peer_id: &str,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    blocked_peers: &HashSet<String>,
    channel_creators: &HashMap<String, String>,
    chat_context: &ChatContext,
    password_protected_channels: &HashSet<String>,
    channel_key_commitments: &HashMap<String, String>,
    app_state: &AppState,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
) -> bool {
    if line.starts_with("/name ") {
        let new_name = line[6..].trim();
        if new_name.is_empty() {
            println!("\x1b[93m‚ö† Usage: /name <new_nickname>\x1b[0m");
            println!("\x1b[90mExample: /name Alice\x1b[0m");
        } else if new_name.len() > 20 {
            println!("\x1b[93m‚ö† Nickname too long\x1b[0m");
            println!("\x1b[90mMaximum 20 characters allowed.\x1b[0m");
        } else if new_name.contains(|c: char| !c.is_alphanumeric() && c != '-' && c != '_') {
            println!("\x1b[93m‚ö† Invalid nickname\x1b[0m");
            println!("\x1b[90mNicknames can only contain letters, numbers, hyphens and underscores.\x1b[0m");
        } else if new_name == "system" || new_name == "all" {
            println!("\x1b[93m‚ö† Reserved nickname\x1b[0m");
            println!("\x1b[90mThis nickname is reserved and cannot be used.\x1b[0m");
        } else {
            *nickname = new_name.to_string();
            let announce_packet = create_bitchat_packet(my_peer_id, MessageType::Announce, nickname.as_bytes().to_vec());
            if peripheral.write(cmd_char, &announce_packet, WriteType::WithoutResponse).await.is_err() {
                println!("[!] Failed to announce new nickname");
            } else {
                println!("\x1b[90m¬ª Nickname changed to: {}\x1b[0m", nickname);
                let state_to_save = create_app_state(
                    blocked_peers,
                    channel_creators,
                    &chat_context.active_channels,
                    password_protected_channels,
                    channel_key_commitments,
                    &app_state.encrypted_channel_passwords,
                    nickname
                );
                if let Err(e) = save_state(&state_to_save) {
                    eprintln!("Warning: Could not save nickname: {}", e);
                }
            }
        }
        return true;
    }
    false
}

fn handle_list_command(line: &str, chat_context: &mut ChatContext) -> bool {
    if line == "/list" {
        chat_context.show_conversation_list();
        return true;
    }
    false
}

// Handler for /j command (join channel)
async fn handle_join_command(
    line: &str,
    password_protected_channels: &HashSet<String>,
    channel_keys: &mut HashMap<String, [u8; 32]>,
    discovered_channels: &mut HashSet<String>,
    chat_context: &mut ChatContext,
    channel_key_commitments: &HashMap<String, String>,
    app_state: &mut AppState,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    nickname: &str,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    channel_creators: &HashMap<String, String>,
) -> bool {
    if line.starts_with("/j ") {
        let parts: Vec<&str> = line.split_whitespace().collect();
        let channel_name = parts.get(1).unwrap_or(&"").to_string();
        
        // Validate channel name
        if channel_name.is_empty() {
            println!("\x1b[93m‚ö† Usage: /j #<channel> [password]\x1b[0m");
            println!("\x1b[90mExample: /j #general\x1b[0m");
            println!("\x1b[90mExample: /j #private mysecret\x1b[0m");
            return true;
        }
        
        if !channel_name.starts_with("#") {
            println!("\x1b[93m‚ö† Channel names must start with #\x1b[0m");
            println!("\x1b[90mExample: /j #{}\x1b[0m", channel_name);
            return true;
        }
        
        if channel_name.len() > 25 {
            println!("\x1b[93m‚ö† Channel name too long\x1b[0m");
            println!("\x1b[90mMaximum 25 characters allowed.\x1b[0m");
            return true;
        }
        
        if channel_name[1..].contains(|c: char| !c.is_alphanumeric() && c != '-' && c != '_') {
            println!("\x1b[93m‚ö† Invalid channel name\x1b[0m");
            println!("\x1b[90mChannel names can only contain letters, numbers, hyphens and underscores.\x1b[0m");
            return true;
        }

        if channel_name.starts_with("#") {
            // Check if channel is password-protected
            if password_protected_channels.contains(&channel_name) {
                // Check if we already have a key (from auto-restore)
                if channel_keys.contains_key(&channel_name) {
                    // We have the key from restoration, just switch to the channel
                    discovered_channels.insert(channel_name.clone());
                    chat_context.switch_to_channel(&channel_name);
                    print!("> ");
                    std::io::stdout().flush().unwrap();
                    return true;
                }
                // We don't have the key, require password
                if let Some(password) = parts.get(2) {
                    if password.len() < 4 {
                        println!("\x1b[93m‚ö† Password too short\x1b[0m");
                        println!("\x1b[90mMinimum 4 characters required.\x1b[0m");
                        return true;
                    }
                    let key = EncryptionService::derive_channel_key(password, &channel_name);
                    
                    // Verify password against stored key commitment (iOS compatibility)
                    if let Some(expected_commitment) = channel_key_commitments.get(&channel_name) {
                        let test_commitment = {
                            let hash = sha2::Sha256::digest(&key);
                            hex::encode(hash)
                        };
                        
                        if &test_commitment != expected_commitment {
                            // Match iOS error message exactly
                            println!("‚ùå wrong password for channel {}. please enter the correct password.", channel_name);
                            return true;
                        }
                        debug_println!("[CHANNEL] Password verified for {}", channel_name);
                    }
                    
                    channel_keys.insert(channel_name.clone(), key);
                    discovered_channels.insert(channel_name.clone());
                    
                    // Save encrypted password (matching iOS Keychain behavior)
                    if let Some(identity_key) = &app_state.identity_key {
                        match encrypt_password(password, identity_key) {
                            Ok(encrypted) => {
                                app_state.encrypted_channel_passwords.insert(channel_name.clone(), encrypted);
                                debug_println!("[CHANNEL] Saved encrypted password for {}", channel_name);
                                
                                // Save state immediately
                                let state_to_save = create_app_state(
                                    &HashSet::new(), // blocked_peers
                                    &HashMap::new(), // channel_creators
                                    &chat_context.active_channels,
                                    &HashSet::new(), // password_protected_channels
                                    &HashMap::new(), // channel_key_commitments
                                    &app_state.encrypted_channel_passwords,
                                    nickname
                                );
                                if let Err(e) = save_state(&state_to_save) {
                                    eprintln!("Warning: Could not save state: {}", e);
                                }
                            }
                            Err(e) => {
                                debug_println!("[CHANNEL] Failed to encrypt password: {}", e);
                            }
                        }
                    }
                    
                    discovered_channels.insert(channel_name.clone());
                    chat_context.switch_to_channel_silent(&channel_name);
                    // Clear the prompt that was already printed by the input reader
                    print!("\r\x1b[K");
                    println!("\x1b[90m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\x1b[0m");
                    println!("\x1b[90m¬ª Joined password-protected channel: {} üîí\x1b[0m", channel_name);
                    
                    // Send channel announce to let others know we joined with correct password
                    // This matches iOS behavior
                    if let Some(owner) = channel_creators.get(&channel_name) {
                        let key_commitment = {
                            let hash = sha2::Sha256::digest(&key);
                            hex::encode(hash)
                        };
                        debug_println!("[CHANNEL] Sending join announce for password channel {}", channel_name);
                        let _ = send_channel_announce(
                            peripheral,
                            cmd_char,
                            owner, // Use existing owner
                            &channel_name,
                            true,
                            Some(&key_commitment)
                        ).await;
                    }
                    
                    print!("> ");
                    std::io::stdout().flush().unwrap();
                } else {
                    println!("‚ùå Channel {} is password-protected. Use: /j {} <password>", channel_name, channel_name);
                    return true;
                }
            } else {
                // Not password-protected or we have the key
                if let Some(password) = parts.get(2) {
                    // User provided password for a channel we haven't seen as protected yet
                    let key = EncryptionService::derive_channel_key(password, &channel_name);
                    channel_keys.insert(channel_name.clone(), key);
                    discovered_channels.insert(channel_name.clone());
                    chat_context.switch_to_channel_silent(&channel_name);
                    // Clear the prompt that was already printed by the input reader
                    print!("\r\x1b[K");
                    println!("\x1b[90m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\x1b[0m");
                    println!("\x1b[90m¬ª Joined password-protected channel: {} üîí. Just type to send messages.\x1b[0m", channel_name);
                    
                    // Send channel announce to let others know we joined with correct password
                    // This matches iOS behavior
                    if let Some(owner) = channel_creators.get(&channel_name) {
                        let key_commitment = {
                            let hash = sha2::Sha256::digest(&key);
                            hex::encode(hash)
                        };
                        debug_println!("[CHANNEL] Sending join announce for password channel {}", channel_name);
                        let _ = send_channel_announce(
                            peripheral,
                            cmd_char,
                            owner, // Use existing owner
                            &channel_name,
                            true,
                            Some(&key_commitment)
                        ).await;
                    }
                    
                    print!("> ");
                    std::io::stdout().flush().unwrap();
                } else {
                    // Regular channel join
                    discovered_channels.insert(channel_name.clone());
                    print!("\r\x1b[K");
                    chat_context.switch_to_channel(&channel_name);
                    channel_keys.remove(&channel_name); // Remove any previous key
                    
                    // Don't claim ownership - let it be established when first password is set
                    // This matches iOS behavior
                    if !channel_creators.contains_key(&channel_name) {
                        debug_println!("[CHANNEL] No owner recorded for {}. First to set password will become owner.", channel_name);
                    }
                    
                    print!("> ");
                    std::io::stdout().flush().unwrap();
                }
            }
            debug_println!("{}", chat_context.get_status_line());
        } else {
            println!("¬ª Invalid channel name. It must start with #.");
        }
        return true;
    }
    false
}

// Handler for /exit command
fn handle_exit_command(
    line: &str,
    blocked_peers: &HashSet<String>,
    channel_creators: &HashMap<String, String>,
    chat_context: &ChatContext,
    password_protected_channels: &HashSet<String>,
    channel_key_commitments: &HashMap<String, String>,
    app_state: &AppState,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    nickname: &str,
) -> bool {
    if line == "/exit" { 
        // Save state before exiting
        let state_to_save = create_app_state(
            blocked_peers,
            channel_creators,
            &chat_context.active_channels,
            password_protected_channels,
            channel_key_commitments,
            &app_state.encrypted_channel_passwords,
            nickname
        );
        if let Err(e) = save_state(&state_to_save) {
            eprintln!("Warning: Could not save state: {}", e);
        }
        return true;
    }
    false
}

// Handler for /reply command
fn handle_reply_command(line: &str, chat_context: &mut ChatContext) -> bool {
    if line == "/reply" {
        if let Some((peer_id, nickname)) = chat_context.last_private_sender.clone() {
            chat_context.enter_dm_mode(&nickname, &peer_id);
            debug_println!("{}", chat_context.get_status_line());
        } else {
            println!("¬ª No private messages received yet.");
        }
        return true;
    }
    false
}

// Handler for /public command
fn handle_public_command(line: &str, chat_context: &mut ChatContext) -> bool {
    if line == "/public" {
        chat_context.switch_to_public();
        debug_println!("{}", chat_context.get_status_line());
        return true;
    }
    false
}

// Handler for /online command
fn handle_online_command(line: &str, peers: &Arc<Mutex<HashMap<String, Peer>>>) -> bool {
    if line == "/online" || line == "/w" {
        let peers_lock = peers.lock().unwrap();
        if peers_lock.is_empty() {
            println!("¬ª No one else is online right now.");
        } else {
            let mut online_list: Vec<String> = peers_lock.iter()
                .filter_map(|(_, peer)| peer.nickname.clone())
                .collect();
            online_list.sort();
            println!("¬ª Online users: {}", online_list.join(", "));
        }
        print!("> ");
        std::io::stdout().flush().unwrap();
        return true;
    }
    false
}

// Handler for /channels command
fn handle_channels_command(
    line: &str,
    chat_context: &ChatContext,
    channel_keys: &HashMap<String, [u8; 32]>,
    password_protected_channels: &HashSet<String>,
) -> bool {
    if line == "/channels" {
        let mut all_channels: HashSet<String> = HashSet::new();
        
        // Add channels from chat context
        all_channels.extend(chat_context.active_channels.iter().cloned());
        
        // Add channels from channel_keys (password protected ones we know about)
        all_channels.extend(channel_keys.keys().cloned());
        
        if all_channels.is_empty() {
            println!("¬ª No channels discovered yet. Channels appear as people use them.");
        } else {
            let mut channel_list: Vec<String> = all_channels.into_iter().collect();
            channel_list.sort();
            
            println!("¬ª Discovered channels:");
            for channel in channel_list {
                let mut status = String::new();
                
                // Check if joined
                if chat_context.active_channels.contains(&channel) {
                    status.push_str(" ‚úì");
                }
                
                // Check if password protected
                if password_protected_channels.contains(&channel) {
                    status.push_str(" üîí");
                    if channel_keys.contains_key(&channel) {
                        status.push_str(" üîë"); // We have the key
                    }
                }
                
                println!("  {}{}", channel, status);
            }
            println!("\n‚úì = joined, üîí = password protected, üîë = authenticated");
        }
        print!("> ");
        std::io::stdout().flush().unwrap();
        return true;
    }
    false
}

// Handler for /dm command (direct message)
async fn handle_dm_command(
    line: &str,
    chat_context: &mut ChatContext,
    peers: &Arc<Mutex<HashMap<String, Peer>>>,
    nickname: &str,
    my_peer_id: &str,
    delivery_tracker: &mut DeliveryTracker,
    encryption_service: &EncryptionService,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
) -> bool {
    if line.starts_with("/dm ") {
        let parts: Vec<&str> = line.splitn(3, ' ').collect();
        
        // Check if it's just "/dm nickname" (enter DM mode) or "/dm nickname message" (quick send)
        if parts.len() < 2 {
            println!("\x1b[93m‚ö† Usage: /dm <nickname> [message]\x1b[0m");
            println!("\x1b[90mExample: /dm Bob Hey there!\x1b[0m");
            return true;
        }
        
        let target_nickname = parts[1];
        
        // Find peer ID for nickname
        let peer_id = {
            let peers = peers.lock().unwrap();
            peers.iter()
                .find(|(_, peer)| peer.nickname.as_deref() == Some(target_nickname))
                .map(|(id, _)| id.clone())
        };
        
        if let Some(target_peer_id) = peer_id {
            // If no message provided, enter DM mode
            if parts.len() == 2 {
                chat_context.enter_dm_mode(target_nickname, &target_peer_id);
                debug_println!("{}", chat_context.get_status_line());
                return true;
            }
            
            // Otherwise send the message directly
            let private_message = parts[2];
            // Create private message
            debug_println!("[PRIVATE] Sending encrypted message to {}", target_nickname);
            
            // Create message payload with private flag
            let (message_payload, message_id) = create_bitchat_message_payload_full(&nickname, private_message, None, true, &my_peer_id);
            
            // Track private message for delivery confirmation
            delivery_tracker.track_message(message_id.clone(), private_message.to_string(), true);
            
            // Pad the message for privacy using PKCS#7
            let block_sizes = [256, 512, 1024, 2048];
            let payload_size = message_payload.len();
            let target_size = block_sizes.iter()
                .find(|&&size| payload_size + 16 <= size)
                .copied()
                .unwrap_or(payload_size);
            
            let padding_needed = target_size - message_payload.len();
            let mut padded_payload = message_payload.clone();
            
            if padding_needed > 0 && padding_needed <= 255 {
                // PKCS#7 padding: all padding bytes have the same value (the padding length)
                for _ in 0..padding_needed {
                    padded_payload.push(padding_needed as u8);
                }
                debug_println!("[PRIVATE] Added {} bytes of PKCS#7 padding", padding_needed);
            } else if padding_needed == 0 {
                // If already at block size, don't add more padding - Android doesn't do this
                debug_println!("[PRIVATE] Message already at block size, no padding needed");
            }
            
            // Encrypt the padded payload for the recipient
            match encryption_service.encrypt(&padded_payload, &target_peer_id) {
                Ok(encrypted) => {
                    debug_println!("[PRIVATE] Encrypted payload: {} bytes", encrypted.len());
                    
                    // Sign the encrypted payload
                    let signature = encryption_service.sign(&encrypted);
                    
                    // Create packet with recipient ID for private routing
                    let packet = create_bitchat_packet_with_recipient_and_signature(
                        &my_peer_id,
                        &target_peer_id,  // Specify the recipient
                        MessageType::Message,
                        encrypted,
                        Some(signature)
                    );
                    
                    // Send the private message
                    if let Err(_e) = send_packet_with_fragmentation(&peripheral, cmd_char, packet, &my_peer_id).await {
                        println!("\n\x1b[91m‚ùå Failed to send private message\x1b[0m");
                        println!("\x1b[90mThe message could not be delivered. Connection may have been lost.\x1b[0m");
                    } else {
                        debug_println!("[PRIVATE] Message sent to {}", target_nickname);
                    }
                },
                Err(e) => {
                    println!("[!] Failed to encrypt private message: {:?}", e);
                    println!("[!] Make sure you have received key exchange from {}", target_nickname);
                }
            }
            return true;
        } else {
            println!("\x1b[93m‚ö† User '{}' not found\x1b[0m", target_nickname);
            println!("\x1b[90mThey may be offline or using a different nickname.\x1b[0m");
            return true;
        }
    }
    false
}

// Handler for /block command
fn handle_block_command(
    line: &str,
    blocked_peers: &mut HashSet<String>,
    peers: &Arc<Mutex<HashMap<String, Peer>>>,
    encryption_service: &EncryptionService,
    channel_creators: &HashMap<String, String>,
    chat_context: &ChatContext,
    password_protected_channels: &HashSet<String>,
    channel_key_commitments: &HashMap<String, String>,
    app_state: &AppState,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    _nickname: &str,
) -> bool {
    if line.starts_with("/block") {
        let parts: Vec<&str> = line.split_whitespace().collect();
        
        if parts.len() == 1 {
            // List blocked peers
            if blocked_peers.is_empty() {
                println!("¬ª No blocked peers.");
            } else {
                // Find nicknames for blocked fingerprints
                let peers_guard = peers.lock().unwrap();
                let mut blocked_nicknames = Vec::new();
                
                for (peer_id, peer) in peers_guard.iter() {
                    if let Some(fingerprint) = encryption_service.get_peer_fingerprint(peer_id) {
                        if blocked_peers.contains(&fingerprint) {
                            if let Some(nickname) = &peer.nickname {
                                blocked_nicknames.push(nickname.clone());
                            }
                        }
                    }
                }
                
                if blocked_nicknames.is_empty() {
                    println!("¬ª Blocked peers (not currently online): {}", blocked_peers.len());
                } else {
                    println!("¬ª Blocked peers: {}", blocked_nicknames.join(", "));
                }
            }
        } else if parts.len() == 2 {
            // Block a specific peer
            let target_name = parts[1];
            let nickname = if target_name.starts_with("@") {
                &target_name[1..]
            } else {
                target_name
            };
            
            // Find peer ID for nickname
            let peer_id = {
                let peers_guard = peers.lock().unwrap();
                peers_guard.iter()
                    .find(|(_, peer)| peer.nickname.as_deref() == Some(nickname))
                    .map(|(id, _)| id.clone())
            };
            
            if let Some(target_peer_id) = peer_id {
                if let Some(fingerprint) = encryption_service.get_peer_fingerprint(&target_peer_id) {
                    if blocked_peers.contains(&fingerprint) {
                        println!("¬ª {} is already blocked.", nickname);
                    } else {
                        blocked_peers.insert(fingerprint.clone());
                        
                        // Save state
                        let state_to_save = create_app_state(
                            blocked_peers,
                            channel_creators,
                            &chat_context.active_channels,
                            password_protected_channels,
                            channel_key_commitments,
                            &app_state.encrypted_channel_passwords,
                            nickname
                        );
                        if let Err(e) = save_state(&state_to_save) {
                            eprintln!("Warning: Could not save state: {}", e);
                        }
                        
                        println!("\n\x1b[92m‚úì Blocked {}\x1b[0m", nickname);
                        println!("\x1b[90m{} will no longer be able to send you messages.\x1b[0m", nickname);
                    }
                } else {
                    println!("¬ª Cannot block {}: No identity key received yet.", nickname);
                }
            } else {
                println!("\x1b[93m‚ö† User '{}' not found\x1b[0m", nickname);
                println!("\x1b[90mThey may be offline or haven't sent any messages yet.\x1b[0m");
            }
        } else {
            println!("\x1b[93m‚ö† Usage: /block @<nickname>\x1b[0m");
            println!("\x1b[90mExample: /block @spammer\x1b[0m");
        }
        return true;
    }
    false
}

// Handler for /unblock command
fn handle_unblock_command(
    line: &str,
    blocked_peers: &mut HashSet<String>,
    peers: &Arc<Mutex<HashMap<String, Peer>>>,
    encryption_service: &EncryptionService,
    channel_creators: &HashMap<String, String>,
    chat_context: &ChatContext,
    password_protected_channels: &HashSet<String>,
    channel_key_commitments: &HashMap<String, String>,
    app_state: &AppState,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    _nickname: &str,
) -> bool {
    if line.starts_with("/unblock ") {
        let parts: Vec<&str> = line.split_whitespace().collect();
        
        if parts.len() != 2 {
            println!("\x1b[93m‚ö† Usage: /unblock @<nickname>\x1b[0m");
            println!("\x1b[90mExample: /unblock @friend\x1b[0m");
            return true;
        }
        
        let target_name = parts[1];
        let nickname = if target_name.starts_with("@") {
            &target_name[1..]
        } else {
            target_name
        };
        
        // Find peer ID for nickname
        let peer_id = {
            let peers_guard = peers.lock().unwrap();
            peers_guard.iter()
                .find(|(_, peer)| peer.nickname.as_deref() == Some(nickname))
                .map(|(id, _)| id.clone())
        };
        
        if let Some(target_peer_id) = peer_id {
            if let Some(fingerprint) = encryption_service.get_peer_fingerprint(&target_peer_id) {
                if blocked_peers.contains(&fingerprint) {
                    blocked_peers.remove(&fingerprint);
                    
                    // Save state
                    let state_to_save = create_app_state(
                        blocked_peers,
                        channel_creators,
                        &chat_context.active_channels,
                        password_protected_channels,
                        channel_key_commitments,
                        &app_state.encrypted_channel_passwords,
                        nickname
                    );
                    if let Err(e) = save_state(&state_to_save) {
                        eprintln!("Warning: Could not save state: {}", e);
                    }
                    
                    println!("\n\x1b[92m‚úì Unblocked {}\x1b[0m", nickname);
                    println!("\x1b[90m{} can now send you messages again.\x1b[0m", nickname);
                } else {
                    println!("\x1b[93m‚ö† {} is not blocked\x1b[0m", nickname);
                }
            } else {
                println!("¬ª Cannot unblock {}: No identity key received.", nickname);
            }
        } else {
            println!("\x1b[93m‚ö† User '{}' not found\x1b[0m", nickname);
            println!("\x1b[90mThey may be offline or haven't sent any messages yet.\x1b[0m");
        }
        return true;
    }
    false
}

// Handler for /clear command
fn handle_clear_command(line: &str, chat_context: &ChatContext) -> bool {
    if line == "/clear" {
        // Clear the terminal screen
        print!("\x1b[2J\x1b[1;1H");
        
        // Reprint the ASCII art logo in Matrix green
        println!("\n\x1b[38;5;46m##\\       ##\\   ##\\               ##\\                  ##\\");
        println!("## |      \\__|  ## |              ## |                 ## |");
        println!("#######\\  ##\\ ######\\    #######\\ #######\\   ######\\ ######\\");
        println!("##  __##\\ ## |\\_##  _|  ##  _____|##  __##\\  \\____##\\\\_##  _|");
        println!("## |  ## |## |  ## |    ## /      ## |  ## | ####### | ## |");
        println!("## |  ## |## |  ## |##\\ ## |      ## |  ## |##  __## | ## |##\\");
        println!("#######  |## |  \\####  |\\#######\\ ## |  ## |\\####### | \\####  |");
        println!("\\_______/ \\__|   \\____/  \\_______|\\__|  \\__| \\_______|  \\____/\x1b[0m");
        println!("\n\x1b[38;5;40m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\x1b[0m");
        println!("\x1b[38;5;40mDecentralized ‚Ä¢ Encrypted ‚Ä¢ Peer-to-Peer ‚Ä¢ Open Source\x1b[0m");
        println!("\x1b[38;5;40m                bitchat@ the terminal {}\x1b[0m", VERSION);
        println!("\x1b[38;5;40m‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\x1b[0m\n");
        
        // Show current context
        match &chat_context.current_mode {
            ChatMode::Public => {
                println!("¬ª Cleared public chat");
            },
            ChatMode::Channel(channel) => {
                println!("¬ª Cleared channel {}", channel);
            },
            ChatMode::PrivateDM { nickname, .. } => {
                println!("¬ª Cleared DM with {}", nickname);
            }
        }
        
        print!("> ");
        std::io::stdout().flush().unwrap();
        return true;
    }
    false
}

// Handler for /status command
fn handle_status_command(
    line: &str,
    peers: &Arc<Mutex<HashMap<String, Peer>>>,
    chat_context: &ChatContext,
    nickname: &str,
    my_peer_id: &str,
) -> bool {
    if line == "/status" {
        let peer_count = peers.lock().unwrap().len();
        let channel_count = chat_context.active_channels.len();
        let dm_count = chat_context.active_dms.len();
        
        println!("\n‚ï≠‚îÄ‚îÄ‚îÄ Connection Status ‚îÄ‚îÄ‚îÄ‚ïÆ");
        println!("‚îÇ Peers connected: {:3}    ‚îÇ", peer_count);
        println!("‚îÇ Active channels: {:3}    ‚îÇ", channel_count);
        println!("‚îÇ Active DMs:      {:3}    ‚îÇ", dm_count);
        println!("‚îÇ                         ‚îÇ");
        println!("‚îÇ Your nickname: {:^9}‚îÇ", if nickname.len() > 9 { &nickname[..9] } else { &nickname });
        println!("‚îÇ Your ID: {}...‚îÇ", &my_peer_id[..8]);
        println!("‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ");
        print!("> ");
        std::io::stdout().flush().unwrap();
        return true;
    }
    false
}

// Handler for /leave command
async fn handle_leave_command(
    line: &str,
    chat_context: &mut ChatContext,
    channel_keys: &mut HashMap<String, [u8; 32]>,
    password_protected_channels: &mut HashSet<String>,
    channel_creators: &mut HashMap<String, String>,
    channel_key_commitments: &mut HashMap<String, String>,
    app_state: &mut AppState,
    blocked_peers: &HashSet<String>,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    nickname: &str,
    my_peer_id: &str,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
) -> bool {
    if line == "/leave" {
        match &chat_context.current_mode {
            ChatMode::Channel(channel) => {
                let channel_name = channel.clone();
                
                // Send leave notification packet (iOS compatible)
                let leave_payload = channel_name.as_bytes().to_vec();
                let leave_packet = create_bitchat_packet(&my_peer_id, MessageType::Leave, leave_payload);
                
                // Set TTL to 3 for leave messages (matching iOS)
                let mut leave_packet_with_ttl = leave_packet;
                if leave_packet_with_ttl.len() > 2 {
                    leave_packet_with_ttl[2] = 3; // TTL position
                }
                
                if let Err(_e) = peripheral.write(cmd_char, &leave_packet_with_ttl, WriteType::WithoutResponse).await {
                    // Silently ignore leave notification failures - not critical
                }
                
                // Clean up local state
                channel_keys.remove(&channel_name);
                password_protected_channels.remove(&channel_name);
                channel_creators.remove(&channel_name);
                channel_key_commitments.remove(&channel_name);
                
                // Remove from encrypted passwords
                app_state.encrypted_channel_passwords.remove(&channel_name);
                
                // Update chat context
                chat_context.remove_channel(&channel_name);
                chat_context.switch_to_public();
                
                // Save state
                let state_to_save = create_app_state(
                    blocked_peers,
                    channel_creators,
                    &chat_context.active_channels,
                    password_protected_channels,
                    channel_key_commitments,
                    &app_state.encrypted_channel_passwords,
                    nickname
                );
                if let Err(e) = save_state(&state_to_save) {
                    eprintln!("Warning: Could not save state: {}", e);
                }
                
                println!("\x1b[90m¬ª Left channel {}\x1b[0m", channel_name);
                print!("> ");
                std::io::stdout().flush().unwrap();
            },
            _ => {
                println!("¬ª You're not in a channel. Use /j #channel to join one.");
            }
        }
        return true;
    }
    false
}

// Handler for /pass command (set/change channel password)
async fn handle_pass_command(
    line: &str,
    chat_context: &ChatContext,
    channel_creators: &mut HashMap<String, String>,
    channel_keys: &mut HashMap<String, [u8; 32]>,
    password_protected_channels: &mut HashSet<String>,
    channel_key_commitments: &mut HashMap<String, String>,
    app_state: &mut AppState,
    blocked_peers: &HashSet<String>,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    nickname: &str,
    my_peer_id: &str,
    encryption_service: &EncryptionService,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
) -> bool {
    if line.starts_with("/pass ") {
        let parts: Vec<&str> = line.split_whitespace().collect();
        
        // Check if user is in a channel
        if let ChatMode::Channel(channel) = &chat_context.current_mode {
            // Check if user is the channel owner
            if let Some(owner) = channel_creators.get(channel) {
                if owner == &my_peer_id {
                    if parts.len() >= 2 {
                        let new_password = parts[1..].join(" ");
                        
                        if new_password.len() < 4 {
                            println!("\x1b[93m‚ö† Password too short\x1b[0m");
                            println!("\x1b[90mMinimum 4 characters required.\x1b[0m");
                            return true;
                        }
                        
                        // Derive new key
                        let new_key = EncryptionService::derive_channel_key(&new_password, channel);
                        
                        // Store old key for notification
                        let old_key = channel_keys.get(channel).cloned();
                        
                        // Update keys and mark as protected
                        channel_keys.insert(channel.clone(), new_key);
                        password_protected_channels.insert(channel.clone());
                        
                        // Save encrypted password (matching iOS Keychain behavior)
                        if let Some(identity_key) = &app_state.identity_key {
                            match encrypt_password(&new_password, identity_key) {
                                Ok(encrypted) => {
                                    app_state.encrypted_channel_passwords.insert(channel.clone(), encrypted);
                                    debug_println!("[CHANNEL] Saved encrypted password for {}", channel);
                                }
                                Err(e) => {
                                    debug_println!("[CHANNEL] Failed to encrypt password: {}", e);
                                }
                            }
                        }
                        
                        // Calculate key commitment (SHA256 of key)
                        use sha2::Digest;
                        let mut hasher = Sha256::new();
                        hasher.update(&new_key);
                        let commitment = hasher.finalize();
                        let commitment_hex = hex::encode(&commitment);
                        
                        // Send notification with old key if exists
                        if let Some(old_key) = old_key {
                            let notify_msg = "üîê Password changed by channel owner. Please update your password.";
                            let encrypted_notify = match encryption_service.encrypt_with_key(notify_msg.as_bytes(), &old_key) {
                                Ok(enc) => enc,
                                Err(_) => Vec::new(),
                            };
                            
                            if !encrypted_notify.is_empty() {
                                let (notify_payload, _) = create_encrypted_channel_message_payload(
                                    &nickname, notify_msg, channel, &old_key, &encryption_service, &my_peer_id
                                );
                                let notify_packet = create_bitchat_packet(&my_peer_id, MessageType::Message, notify_payload);
                                let _ = send_packet_with_fragmentation(&peripheral, cmd_char, notify_packet, &my_peer_id).await;
                            }
                        }
                        
                        // Send channel announce with new key commitment
                        if let Err(e) = send_channel_announce(
                            &peripheral,
                            cmd_char,
                            &my_peer_id,
                            channel,
                            true,
                            Some(&commitment_hex),
                        ).await {
                            println!("[!] Failed to announce password change: {}", e);
                        }
                        
                        // Send initialization message with new key
                        let init_msg = format!("üîë Password {} | Channel {} password {} by {} | Metadata: {}",
                            if old_key.is_some() { "changed" } else { "set" },
                            channel,
                            if old_key.is_some() { "updated" } else { "protected" },
                            nickname,
                            hex::encode(&my_peer_id.as_bytes())
                        );
                        
                        let (init_payload, _) = create_encrypted_channel_message_payload(
                            &nickname, &init_msg, channel, &new_key, &encryption_service, &my_peer_id
                        );
                        let init_packet = create_bitchat_packet(&my_peer_id, MessageType::Message, init_payload);
                        let _ = send_packet_with_fragmentation(&peripheral, cmd_char, init_packet, &my_peer_id).await;
                        
                        // Save state
                        let state_to_save = create_app_state(
                            blocked_peers,
                            channel_creators,
                            &chat_context.active_channels,
                            password_protected_channels,
                            channel_key_commitments,
                            &app_state.encrypted_channel_passwords,
                            nickname
                        );
                        if let Err(e) = save_state(&state_to_save) {
                            eprintln!("Warning: Could not save state: {}", e);
                        }
                        
                        println!("¬ª Password {} for {}.", 
                            if old_key.is_some() { "changed" } else { "set" },
                            channel
                        );
                        println!("¬ª Members will need to rejoin with: /j {} {}", channel, new_password);
                    } else {
                        println!("\x1b[93m‚ö† Usage: /pass <new password>\x1b[0m");
                        println!("\x1b[90mExample: /pass mysecret123\x1b[0m");
                    }
                } else {
                    println!("¬ª Only the channel owner can change the password.");
                }
            } else {
                // No owner recorded - first to set password becomes owner (iOS behavior)
                if parts.len() >= 2 {
                    let new_password = parts[1..].join(" ");
                    
                    // Claim ownership
                    channel_creators.insert(channel.clone(), my_peer_id.to_string());
                    
                    // Derive key
                    let new_key = EncryptionService::derive_channel_key(&new_password, channel);
                    
                    // Update keys and mark as protected
                    channel_keys.insert(channel.clone(), new_key);
                    password_protected_channels.insert(channel.clone());
                    
                    // Save encrypted password (matching iOS Keychain behavior)
                    if let Some(identity_key) = &app_state.identity_key {
                        match encrypt_password(&new_password, identity_key) {
                            Ok(encrypted) => {
                                app_state.encrypted_channel_passwords.insert(channel.clone(), encrypted);
                                debug_println!("[CHANNEL] Saved encrypted password for {}", channel);
                            }
                            Err(e) => {
                                debug_println!("[CHANNEL] Failed to encrypt password: {}", e);
                            }
                        }
                    }
                    
                    // Calculate key commitment
                    use sha2::Digest;
                    let mut hasher = Sha256::new();
                    hasher.update(&new_key);
                    let commitment = hasher.finalize();
                    let commitment_hex = hex::encode(&commitment);
                    
                    // Send channel announce to claim ownership and announce password
                    debug_println!("[CHANNEL] Claiming ownership of {} and setting password", channel);
                    if let Err(e) = send_channel_announce(
                        &peripheral,
                        cmd_char,
                        &my_peer_id,
                        channel,
                        true,
                        Some(&commitment_hex)
                    ).await {
                        eprintln!("Failed to send channel announce: {}", e);
                    }
                    
                    // Save state
                    let state_to_save = create_app_state(
                        blocked_peers,
                        channel_creators,
                        &chat_context.active_channels,
                        password_protected_channels,
                        channel_key_commitments,
                        &app_state.encrypted_channel_passwords,
                        nickname
                    );
                    if let Err(e) = save_state(&state_to_save) {
                        eprintln!("Warning: Could not save state: {}", e);
                    }
                    
                    println!("¬ª Password set for {}. You are now the channel owner.", channel);
                    println!("¬ª Members will need to rejoin with: /j {} {}", channel, new_password);
                } else {
                    println!("\x1b[93m‚ö† Usage: /pass <new password>\x1b[0m");
                    println!("\x1b[90mExample: /pass mysecret123\x1b[0m");
                }
            }
        } else {
            println!("¬ª You must be in a channel to use /pass.");
        }
        return true;
    }
    false
}

// Handler for private DM messages
async fn handle_private_dm_message(
    line: &str,
    nickname: &str,
    my_peer_id: &str,
    target_nickname: &str,
    target_peer_id: &str,
    delivery_tracker: &mut DeliveryTracker,
    encryption_service: &EncryptionService,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    chat_context: &ChatContext,
) {
    // Only show echo in debug mode
    debug_println!("{} > {}", chat_context.format_prompt(), line);
    debug_println!("[PRIVATE] Sending DM to {} (peer_id: {})", target_nickname, target_peer_id);
    
    // Create message payload with private flag
    let (message_payload, message_id) = create_bitchat_message_payload_full(nickname, line, None, true, my_peer_id);
    
    // Track private message for delivery confirmation
    delivery_tracker.track_message(message_id.clone(), line.to_string(), true);
    
    // Pad the message for privacy using PKCS#7
    let block_sizes = [256, 512, 1024, 2048];
    let payload_size = message_payload.len();
    let target_size = block_sizes.iter()
        .find(|&&size| payload_size + 16 <= size)
        .copied()
        .unwrap_or(payload_size);
    
    let padding_needed = target_size - message_payload.len();
    let mut padded_payload = message_payload.clone();
    
    if padding_needed > 0 && padding_needed <= 255 {
        // PKCS#7 padding: all padding bytes have the same value (the padding length)
        for _ in 0..padding_needed {
            padded_payload.push(padding_needed as u8);
        }
        debug_println!("[PRIVATE] Added {} bytes of PKCS#7 padding", padding_needed);
    } else if padding_needed == 0 {
        // If already at block size, don't add more padding
        debug_println!("[PRIVATE] Message already at block size, no padding needed");
    }
    
    // Encrypt the padded payload for the recipient
    match encryption_service.encrypt(&padded_payload, target_peer_id) {
        Ok(encrypted) => {
            debug_println!("[PRIVATE] Encrypted payload: {} bytes", encrypted.len());
            
            // Sign the encrypted payload
            let signature = encryption_service.sign(&encrypted);
            
            // Create packet with recipient ID for private routing
            let packet = create_bitchat_packet_with_recipient_and_signature(
                my_peer_id,
                target_peer_id,  // Specify the recipient
                MessageType::Message,
                encrypted,
                Some(signature)
            );
            
            // Send the private message
            if let Err(_e) = send_packet_with_fragmentation(peripheral, cmd_char, packet, my_peer_id).await {
                println!("\n\x1b[91m‚ùå Failed to send private message\x1b[0m");
                println!("\x1b[90mThe message could not be delivered. Connection may have been lost.\x1b[0m");
            } else {
                // Show the message was sent in a cleaner format
                let timestamp = chrono::Local::now();
                let display = format_message_display(
                    timestamp,
                    nickname,  // sender
                    line,
                    true, // is_private
                    false, // is_channel
                    None, // channel_name
                    Some(target_nickname), // recipient
                    nickname, // my_nickname
                );
                // Move cursor up to overwrite the input line, clear it, print message
                print!("\x1b[1A\r\x1b[K{}\n", display);
                std::io::stdout().flush().unwrap();
            }
        },
        Err(e) => {
            println!("[!] Failed to encrypt private message: {:?}", e);
            println!("[!] Make sure you have received key exchange from {}", target_nickname);
        }
    }
}

// Handler for regular public/channel messages
async fn handle_regular_message(
    line: &str,
    nickname: &str,
    my_peer_id: &str,
    chat_context: &ChatContext,
    password_protected_channels: &HashSet<String>,
    channel_keys: &mut HashMap<String, [u8; 32]>,
    encryption_service: &EncryptionService,
    delivery_tracker: &mut DeliveryTracker,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
) {
    // Only show echo in debug mode
    debug_println!("{} > {}", chat_context.format_prompt(), line);
    
    let current_channel = chat_context.current_mode.get_channel().map(|s| s.to_string());
    
    // Check if trying to send to password-protected channel without key
    if let Some(ref channel) = current_channel {
        if password_protected_channels.contains(channel) && !channel_keys.contains_key(channel) {
            println!("‚ùå Cannot send to password-protected channel {}. Join with password first.", channel);
            return;
        }
    }
    
    let (message_payload, message_id) = if let Some(ref channel) = current_channel {
        if let Some(channel_key) = channel_keys.get(channel) {
            // Encrypt the message content for the channel
            debug_println!("[ENCRYPT] Encrypting message for channel {} üîí", channel);
            create_encrypted_channel_message_payload(nickname, line, channel, channel_key, encryption_service, my_peer_id)
        } else {
            let payload = create_bitchat_message_payload(nickname, line, current_channel.as_deref());
            (payload, Uuid::new_v4().to_string()) // Generate ID for old style messages
        }
    } else {
        let payload = create_bitchat_message_payload(nickname, line, current_channel.as_deref());
        (payload, Uuid::new_v4().to_string()) // Generate ID for old style messages
    };
    
    // Track the message for delivery confirmation (not for channel messages with 10+ peers)
    let is_private = false;
    delivery_tracker.track_message(message_id.clone(), line.to_string(), is_private);
    
    debug_println!("[MESSAGE] ==================== SENDING USER MESSAGE ====================");
    debug_println!("[MESSAGE] Message content: '{}'", line);
    debug_println!("[MESSAGE] Message payload size: {} bytes", message_payload.len());
    
    // Sign the message payload
    let signature = encryption_service.sign(&message_payload);
    
    // Create the complete message packet with signature
    let message_packet = create_bitchat_packet_with_signature(my_peer_id, MessageType::Message, message_payload.clone(), Some(signature));
    
    // Check if we need to fragment the COMPLETE PACKET (matching Swift behavior)
    if should_fragment(&message_packet) {
        debug_println!("[MESSAGE] Complete packet ({} bytes) requires fragmentation", message_packet.len());
        
        // Use Swift-compatible fragmentation for complete packet
        if let Err(_e) = send_packet_with_fragmentation(peripheral, cmd_char, message_packet, my_peer_id).await {
            println!("\n\x1b[91m‚ùå Message delivery failed\x1b[0m");
            println!("\x1b[90mConnection lost. Please restart BitChat to reconnect.\x1b[0m");
            return;
        }
    } else {
        // Send as single packet without fragmentation
        debug_println!("[MESSAGE] Sending message as single packet ({} bytes)", message_packet.len());
        
        // Use WithResponse for larger packets (matching Swift's 512 byte threshold)
        let write_type = if message_packet.len() > 512 {
            WriteType::WithResponse
        } else {
            WriteType::WithoutResponse
        };
        
        if peripheral.write(cmd_char, &message_packet, write_type).await.is_err() {
            println!("[!] Failed to send message. Connection likely lost.");
            return;
        }
        
        debug_println!("[MESSAGE] ‚úì Successfully sent message packet");
    }
    debug_println!("[MESSAGE] ==================== MESSAGE SEND COMPLETE ====================");
    
    // Display the sent message in a clean format
    let timestamp = chrono::Local::now();
    let display = format_message_display(
        timestamp,
        nickname,
        line,
        false, // is_private
        current_channel.is_some(), // is_channel
        current_channel.as_deref(), // channel_name
        None, // recipient
        nickname // my_nickname
    );
    // Move cursor up to overwrite the input line, clear it, print message
    print!("\x1b[1A\r\x1b[K{}\n", display);
    std::io::stdout().flush().unwrap();
}

// Handler for announce messages
fn handle_announce_message(packet: &BitchatPacket, peers_lock: &mut HashMap<String, Peer>) {
    let peer_nickname = String::from_utf8_lossy(&packet.payload).trim().to_string();

    let is_new_peer = !peers_lock.contains_key(&packet.sender_id_str);
    let peer_entry = peers_lock.entry(packet.sender_id_str.clone()).or_default();

    peer_entry.nickname = Some(peer_nickname.clone());

    // Show connection notification in clean mode only for new peers
    if is_new_peer {
        // Clear any existing prompt and show connection notification in yellow
        print!("\r\x1b[K\x1b[33m{} connected\x1b[0m\n> ", peer_nickname);
        std::io::stdout().flush().unwrap();
    }
    
    debug_println!("[<-- RECV] Announce: Peer {} is now known as '{}'", packet.sender_id_str, peer_nickname);
}

// Handler for message relay
async fn handle_message_relay(
    packet: &BitchatPacket,
    notification_value: &[u8],
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
) {
    debug_full_println!("[DEBUG] Message not for us, checking if we should relay (TTL={})", packet.ttl);
    
    // Relay if TTL > 1
    if packet.ttl > 1 {
        time::sleep(Duration::from_millis(rand::thread_rng().gen_range(10..50))).await;
        let mut relay_data = notification_value.to_vec();
        relay_data[2] = packet.ttl - 1;  // Decrement TTL
        
        if peripheral.write(cmd_char, &relay_data, WriteType::WithoutResponse).await.is_err() {
            println!("[!] Failed to relay message");
        } else {
            debug_full_println!("[DEBUG] Relayed message with TTL={}", packet.ttl - 1);
        }
    }
}

// Handler for private message decryption
fn handle_private_message_decryption(
    packet: &BitchatPacket,
    encryption_service: &EncryptionService,
) -> Option<Vec<u8>> {
    debug_println!("[PRIVATE] This is a private message for us from {}", packet.sender_id_str);
    debug_println!("[PRIVATE] Payload size: {} bytes", packet.payload.len());
    debug_println!("[PRIVATE] First 32 bytes of encrypted payload: {}", hex::encode(&packet.payload[..std::cmp::min(32, packet.payload.len())]));
    
    match encryption_service.decrypt(&packet.payload, &packet.sender_id_str) {
        Ok(decrypted) => {
            debug_println!("[PRIVATE] Successfully decrypted private message!");
            debug_println!("[PRIVATE] Decrypted size: {} bytes", decrypted.len());
            Some(decrypted)
        }
        Err(e) => {
            debug_println!("[PRIVATE] Failed to decrypt private message: {:?}", e);
            debug_println!("[PRIVATE] Checking if we have shared secret with {}", packet.sender_id_str);
            // Private messages MUST be encrypted, skip if decryption fails
            None
        }
    }
}

// Handler for message packets
async fn handle_message_packet(
    packet: &BitchatPacket,
    notification_value: &[u8],
    peers_lock: &mut HashMap<String, Peer>,
    bloom: &mut Bloom<String>,
    discovered_channels: &mut HashSet<String>,
    password_protected_channels: &mut HashSet<String>,
    channel_keys: &mut HashMap<String, [u8; 32]>,
    chat_context: &mut ChatContext,
    delivery_tracker: &mut DeliveryTracker,
    encryption_service: &EncryptionService,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    nickname: &str,
    my_peer_id: &str,
    blocked_peers: &HashSet<String>,
) {
    debug_full_println!("[DEBUG] ==================== MESSAGE RECEIVED ====================");
    debug_full_println!("[DEBUG] Sender: {}", packet.sender_id_str);
    
    // Check if sender is blocked
    if let Some(fingerprint) = encryption_service.get_peer_fingerprint(&packet.sender_id_str) {
        if blocked_peers.contains(&fingerprint) {
            debug_println!("[BLOCKED] Ignoring message from blocked peer: {}", packet.sender_id_str);
            return; // Silent drop
        }
    }
    
    // Check if this is a broadcast or targeted message
    let is_broadcast = packet.recipient_id.as_ref()
        .map(|r| r == &BROADCAST_RECIPIENT)
        .unwrap_or(true);
    
    // Check if message is for us
    let is_for_us = if is_broadcast {
        true
    } else {
        packet.recipient_id_str.as_ref()
            .map(|r| {
                let matches = r == my_peer_id;
                debug_full_println!("[DEBUG] Comparing recipient '{}' with my_peer_id '{}': {}", r, my_peer_id, matches);
                matches
            })
            .unwrap_or(false)
    };
    
    if let Some(ref recipient) = packet.recipient_id_str {
        debug_full_println!("[DEBUG] Recipient: {} (broadcast: {})", recipient, is_broadcast);
    } else {
        debug_full_println!("[DEBUG] Recipient: (none/broadcast)");
    }
    
    debug_full_println!("[DEBUG] Payload size: {} bytes", packet.payload.len());
    
    // Handle messages not for us - relay them
    if !is_for_us {
        handle_message_relay(packet, notification_value, peripheral, cmd_char).await;
        return;
    }
    
    // iOS sends private messages with recipient ID set at packet level
    let is_private_message = !is_broadcast && is_for_us;
    let mut decrypted_payload = None;
    
    // If it's a private message for us, we need to decrypt it
    if is_private_message {
        decrypted_payload = handle_private_message_decryption(packet, encryption_service);
        if decrypted_payload.is_none() {
            return; // Skip if decryption failed
        }
    }
    
    // Parse the message payload
    let parse_result = if is_private_message {
        // For private messages, parse the decrypted and unpadded payload
        if let Some(ref decrypted) = decrypted_payload {
            debug_full_println!("[DEBUG] Parsing decrypted private message payload");
            let unpadded = unpad_message(decrypted);
            debug_full_println!("[DEBUG] After unpadding: {} bytes", unpadded.len());
            parse_bitchat_message_payload(&unpadded)
        } else {
            // If decryption failed but it's a private message, skip it
            debug_full_println!("[DEBUG] Cannot parse private message without decryption");
            return;
        }
    } else {
        // For broadcast messages, parse the payload directly
        debug_full_println!("[DEBUG] Parsing regular message payload");
        parse_bitchat_message_payload(&packet.payload)
    };

    if let Ok(message) = parse_result {
        debug_full_println!("[DEBUG] Message parsed successfully!");
        debug_full_println!("[DEBUG] Message ID: {}", message.id);
        debug_full_println!("[DEBUG] Is encrypted channel: {}", message.is_encrypted);
        debug_full_println!("[DEBUG] Channel: {:?}", message.channel);
        debug_full_println!("[DEBUG] Content length: {} bytes", message.content.len());

        if !bloom.check(&message.id) {
            // Add to bloom filter immediately to prevent duplicate processing
            bloom.set(&message.id);

            let sender_nick = peers_lock.get(&packet.sender_id_str)
                .and_then(|p| p.nickname.as_ref())
                .map_or(&packet.sender_id_str, |n| n);

            // Track discovered channels
            if let Some(channel) = &message.channel {
                discovered_channels.insert(channel.clone());
                debug_println!("[DISCOVERY] Found channel: {}", channel);
                
                // Mark channel as password-protected if we see an encrypted message
                if message.is_encrypted {
                    password_protected_channels.insert(channel.clone());
                    debug_println!("[SECURITY] Marked {} as password-protected", channel);
                }
            }

            {
                // Normal message display with decryption support
                let display_content = if message.is_encrypted {
                    if let Some(channel) = &message.channel {
                        if let Some(channel_key) = channel_keys.get(channel) {
                            // Decrypt the encrypted content
                            if let Some(encrypted_bytes) = &message.encrypted_content {
                                match encryption_service.decrypt_with_key(encrypted_bytes, channel_key) {
                                Ok(decrypted) => String::from_utf8_lossy(&decrypted).to_string(),
                                    Err(_) => "[Encrypted message - decryption failed]".to_string()
                                }
                            } else {
                                "[Encrypted message - no encrypted data]".to_string()
                            }
                        } else {
                            "[Encrypted message - join channel with password]".to_string()
                        }
                    } else {
                        message.content.clone()
                    }
                } else {
                    message.content.clone()
                };

                // Display the message with proper formatting
                let timestamp = chrono::Local::now();
                
                if is_private_message {
                    // Check for iOS cover traffic (dummy messages)
                    if display_content.starts_with(COVER_TRAFFIC_PREFIX) {
                        debug_println!("[COVER] Discarding dummy message from {}", sender_nick);
                        return; // Silently discard cover traffic
                    }
                    
                    // Save the last private sender for replies
                    chat_context.last_private_sender = Some((packet.sender_id_str.clone(), sender_nick.to_string()));
                    chat_context.add_dm(sender_nick, &packet.sender_id_str);
                    
                    let display = format_message_display(
                        timestamp,
                        sender_nick,
                        &display_content,
                        true, // is_private
                        false, // is_channel
                        None, // channel_name
                        Some(nickname), // recipient (me)
                        nickname // my_nickname
                    );
                    // Clear any existing prompt and print the message
                    print!("\r\x1b[K{}\n", display);
                    
                    // Show minimal reply hint
                    if !matches!(&chat_context.current_mode, ChatMode::PrivateDM { .. }) {
                        print!("\x1b[90m¬ª /reply to respond\x1b[0m\n");
                    }
                    print!("> ");
                    std::io::stdout().flush().unwrap();
                    
                    // Update last sender for /reply command
                } else if let Some(channel_name) = &message.channel {
                    // Track this channel
                    chat_context.add_channel(channel_name);
                    
                    let display = format_message_display(
                        timestamp,
                        sender_nick,
                        &display_content,
                        false, // is_private
                        true, // is_channel
                        Some(channel_name), // channel_name
                        None, // recipient
                        nickname // my_nickname
                    );
                    // Clear any existing prompt and print the message
                    print!("\r\x1b[K{}\n", display);
                    std::io::stdout().flush().unwrap();
                } else {
                    // Public message
                    let display = format_message_display(
                        timestamp,
                        sender_nick,
                        &display_content,
                        false, // is_private
                        false, // is_channel
                        None, // channel_name
                        None, // recipient
                        nickname // my_nickname
                    );
                    // Clear any existing prompt and print the message
                    print!("\r\x1b[K{}\n> ", display);
                    std::io::stdout().flush().unwrap();
                }
            }
         
            // Send delivery ACK if needed (matching iOS behavior)
            let active_peer_count = peers_lock.len();
            if should_send_ack(is_private_message, message.channel.as_deref(), None, nickname, active_peer_count) {
                // Check if we've already sent an ACK for this message
                let ack_id = format!("{}-{}", message.id, my_peer_id);
                if delivery_tracker.should_send_ack(&ack_id) {
                    debug_println!("[ACK] Sending delivery ACK for message {}", message.id);
                    
                    // Create ACK payload
                    let ack_payload = create_delivery_ack(
                        &message.id,
                        my_peer_id,
                        nickname,
                        1 // hop count
                    );
                    
                    // Encrypt ACK if it's a private message
                    let final_ack_payload = if is_private_message {
                        // Encrypt the ACK for the sender
                        match encryption_service.encrypt_for_peer(&packet.sender_id_str, &ack_payload) {
                            Ok(encrypted) => encrypted,
                            Err(e) => {
                                debug_println!("[ACK] Failed to encrypt ACK: {:?}", e);
                                ack_payload
                            }
                        }
                    } else {
                        ack_payload
                    };
                    
                    // Create and send ACK packet with TTL=3 (limited propagation)
                    let mut ack_packet = create_bitchat_packet_with_recipient(
                        my_peer_id, 
                        Some(&packet.sender_id_str),
                        MessageType::DeliveryAck, 
                        final_ack_payload,
                        None // No signature for ACKs
                    );
                    
                    // Override TTL to 3 for ACKs
                    if ack_packet.len() > 2 {
                        ack_packet[2] = 3; // TTL position
                    }
                    
                    if let Err(e) = peripheral.write(cmd_char, &ack_packet, WriteType::WithoutResponse).await {
                        debug_println!("[ACK] Failed to send delivery ACK: {}", e);
                    }
                }
            }

            // Relay message if TTL > 1 (matching Swift behavior)
            if packet.ttl > 1 {
                // Don't relay immediately - add small random delay
                time::sleep(Duration::from_millis(rand::thread_rng().gen_range(10..50))).await;
                
                // Create relay packet with decremented TTL
                let mut relay_data = notification_value.to_vec();
                relay_data[2] = packet.ttl - 1;  // Decrement TTL at position 2
                
                if peripheral.write(cmd_char, &relay_data, WriteType::WithoutResponse).await.is_err() {
                    println!("[!] Failed to relay message");
                }
            }
        }
    } else {
        println!("[!] Failed to parse message payload");
        debug_full_println!("[DEBUG] Parse error details:");
        debug_full_println!("[DEBUG] Raw payload hex: {}", hex::encode(&packet.payload));
        if let Some(decrypted) = decrypted_payload {
            debug_full_println!("[DEBUG] Decrypted payload hex: {}", hex::encode(&decrypted));
        }
    }
}

// Handler for fragment packets
async fn handle_fragment_packet(
    packet: &BitchatPacket,
    notification_value: &[u8],
    fragment_collector: &mut FragmentCollector,
    peers_lock: &mut HashMap<String, Peer>,
    bloom: &mut Bloom<String>,
    discovered_channels: &mut HashSet<String>,
    password_protected_channels: &mut HashSet<String>,
    chat_context: &mut ChatContext,
    encryption_service: &EncryptionService,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    nickname: &str,
    my_peer_id: &str,
    blocked_peers: &HashSet<String>,
) {
    // Handle fragment (simplified, following working example)
    if packet.payload.len() >= 13 {
        let mut fragment_id = [0u8; 8];
        fragment_id.copy_from_slice(&packet.payload[0..8]);
        
        let index = ((packet.payload[8] as u16) << 8) | (packet.payload[9] as u16);
        let total = ((packet.payload[10] as u16) << 8) | (packet.payload[11] as u16);
        let original_type = packet.payload[12];
        let fragment_data = packet.payload[13..].to_vec();
        
        // Try to reassemble
        if let Some((complete_data, _sender)) = fragment_collector.add_fragment(
            fragment_id, index, total, original_type, fragment_data, packet.sender_id_str.clone()
        ) {
            // Parse and handle the reassembled packet
            if let Ok(reassembled_packet) = parse_bitchat_packet(&complete_data) {
                if reassembled_packet.msg_type == MessageType::Message {
                    // Check if sender is blocked
                    if let Some(fingerprint) = encryption_service.get_peer_fingerprint(&reassembled_packet.sender_id_str) {
                        if blocked_peers.contains(&fingerprint) {
                            debug_println!("[BLOCKED] Ignoring fragmented message from blocked peer: {}", reassembled_packet.sender_id_str);
                            return; // Silent drop
                        }
                    }
                    
                    // Check if this is a private message that needs decryption
                    let is_broadcast = reassembled_packet.recipient_id.as_ref()
                        .map(|r| r == &BROADCAST_RECIPIENT)
                        .unwrap_or(true);
                    
                    let is_for_us = if is_broadcast {
                        true
                    } else {
                        reassembled_packet.recipient_id_str.as_ref()
                            .map(|r| r == my_peer_id)
                            .unwrap_or(false)
                    };
                    
                    let is_private_message = !is_broadcast && is_for_us;
                    
                    // Handle private messages by decrypting first
                    let message_result = if is_private_message {
                        match encryption_service.decrypt(&reassembled_packet.payload, &reassembled_packet.sender_id_str) {
                            Ok(decrypted) => {
                                debug_println!("[PRIVATE] Successfully decrypted fragmented private message!");
                                debug_println!("[PRIVATE] Decrypted size: {} bytes", decrypted.len());
                                let unpadded = unpad_message(&decrypted);
                                debug_full_println!("[DEBUG] After unpadding: {} bytes", unpadded.len());
                                parse_bitchat_message_payload(&unpadded)
                            },
                            Err(e) => {
                                debug_println!("[PRIVATE] Failed to decrypt fragmented private message: {:?}", e);
                                return;
                            }
                        }
                    } else {
                        // Regular broadcast message
                        parse_bitchat_message_payload(&reassembled_packet.payload)
                    };
                    
                    if let Ok(message) = message_result {
                        if !bloom.check(&message.id) {
                            let sender_nick = peers_lock.get(&reassembled_packet.sender_id_str)
                                .and_then(|p| p.nickname.as_ref())
                                .map_or(&reassembled_packet.sender_id_str, |n| n);
                            
                            {
                                // Track discovered channels from fragmented messages
                                if let Some(channel) = &message.channel {
                                    discovered_channels.insert(channel.clone());
                                    if message.is_encrypted {
                                        password_protected_channels.insert(channel.clone());
                                    }
                                }
                                
                                // Check for iOS cover traffic in private messages
                                if is_private_message && message.content.starts_with(COVER_TRAFFIC_PREFIX) {
                                    debug_println!("[COVER] Discarding fragmented dummy message from {}", sender_nick);
                                    bloom.set(&message.id); // Mark as seen before continuing
                                    return; // Silently discard
                                }
                                
                                // Regular message - display it
                                let timestamp = chrono::Local::now();
                                let display = format_message_display(
                                    timestamp,
                                    sender_nick,
                                    &message.content,
                                    is_private_message, // Use the actual private message flag
                                    message.channel.is_some(), // is_channel
                                    message.channel.as_deref(),
                                    if is_private_message { Some(nickname) } else { None }, // recipient for private messages
                                    nickname // my_nickname
                                );
                                // Clear any existing prompt and print the message
                                print!("\r\x1b[K{}\n> ", display);
                                std::io::stdout().flush().unwrap();
                                
                                // If it's a private message, update chat context
                                if is_private_message {
                                    chat_context.last_private_sender = Some((reassembled_packet.sender_id_str.clone(), sender_nick.to_string()));
                                }
                            }
                            
                            bloom.set(&message.id);
                        }
                    }
                }
            }
        }
    }
    
    // Relay fragments if TTL > 1
    if packet.ttl > 1 {
        time::sleep(Duration::from_millis(rand::thread_rng().gen_range(10..50))).await;
        let mut relay_data = notification_value.to_vec();
        relay_data[2] = packet.ttl - 1;
        
        if peripheral.write(cmd_char, &relay_data, WriteType::WithoutResponse).await.is_err() {
            println!("[!] Failed to relay fragment");
        }
    }
}

// Handler for key exchange messages
async fn handle_key_exchange_message(
    packet: &BitchatPacket,
    peers_lock: &mut HashMap<String, Peer>,
    encryption_service: &EncryptionService,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    my_peer_id: &str,
) {
    // Extract public key
    let public_key = packet.payload.clone();
    debug_println!("[<-- RECV] Key exchange from {} (key: {} bytes)", packet.sender_id_str, public_key.len());
    debug_full_println!("[CRYPTO] Key exchange payload first 32 bytes: {}", hex::encode(&public_key[..std::cmp::min(32, public_key.len())]));
    
    // Add peer's public key to encryption service
    if let Err(e) = encryption_service.add_peer_public_key(&packet.sender_id_str, &public_key) {
        println!("[!] Failed to add peer public key: {:?}", e);
    } else {
        debug_println!("[+] Successfully added encryption keys for peer {}", packet.sender_id_str);
        
        // Send our key exchange back if we haven't already
        if !peers_lock.contains_key(&packet.sender_id_str) {
            debug_full_println!("[CRYPTO] Sending key exchange response to {}", packet.sender_id_str);
            let (key_exchange_payload, _) = generate_keys_and_payload(encryption_service);
            let key_exchange_packet = create_bitchat_packet(my_peer_id, MessageType::KeyExchange, key_exchange_payload);
            if let Err(e) = peripheral.write(cmd_char, &key_exchange_packet, WriteType::WithoutResponse).await {
                println!("[!] Failed to send key exchange response: {}", e);
            }
        }
    }
}

// Handler for leave messages
fn handle_leave_message(
    packet: &BitchatPacket,
    peers_lock: &mut HashMap<String, Peer>,
    chat_context: &ChatContext,
) {
    // Handle leave notification
    let payload_str = String::from_utf8_lossy(&packet.payload).trim().to_string();
    
    if payload_str.starts_with('#') {
        // Channel leave notification
        let channel = payload_str;
        let sender_nick = peers_lock.get(&packet.sender_id_str)
            .and_then(|p| p.nickname.as_ref())
            .map_or(&packet.sender_id_str, |n| n);
        
        // Show leave message only if we're in that channel
        if let ChatMode::Channel(current_channel) = &chat_context.current_mode {
            if current_channel == &channel {
                print!("\r\x1b[K\x1b[90m¬´ {} left {}\x1b[0m\n> ", sender_nick, channel);
                std::io::stdout().flush().unwrap();
            }
        }
        
        debug_println!("[<-- RECV] {} left channel {}", sender_nick, channel);
    } else {
        // Legacy peer disconnect
        peers_lock.remove(&packet.sender_id_str);
        debug_println!("[<-- RECV] Peer {} ({}) has left", packet.sender_id_str, payload_str);
    }
}

// Handler for channel announce messages
fn handle_channel_announce_message(
    packet: &BitchatPacket,
    channel_creators: &mut HashMap<String, String>,
    password_protected_channels: &mut HashSet<String>,
    channel_keys: &mut HashMap<String, [u8; 32]>,
    channel_key_commitments: &mut HashMap<String, String>,
    chat_context: &mut ChatContext,
    blocked_peers: &HashSet<String>,
    encrypted_channel_passwords: &HashMap<String, persistence::EncryptedPassword>,
    nickname: &str,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
) {
    // Parse channel announce: "channel|isProtected|creatorID|keyCommitment"
    let payload_str = String::from_utf8_lossy(&packet.payload);
    let parts: Vec<&str> = payload_str.split('|').collect();
    
    if parts.len() >= 3 {
        let channel = parts[0];
        let is_protected = parts[1] == "1";
        let creator_id = parts[2];
        let _key_commitment = parts.get(3).unwrap_or(&"");
        
        debug_println!("[<-- RECV] Channel announce: {} (protected: {}, owner: {})", 
                     channel, is_protected, creator_id);
        
        // Always update channel creator for any channel announce
        if !creator_id.is_empty() {
            channel_creators.insert(channel.to_string(), creator_id.to_string());
        }
        
        if is_protected {
            password_protected_channels.insert(channel.to_string());
            
            // Store key commitment for verification (matching iOS behavior)
            if !_key_commitment.is_empty() {
                channel_key_commitments.insert(channel.to_string(), _key_commitment.to_string());
                debug_println!("[CHANNEL] Stored key commitment for {}: {}", channel, _key_commitment);
            }
        } else {
            password_protected_channels.remove(channel);
            // If channel is no longer protected, clear keys and commitments
            channel_keys.remove(channel);
            channel_key_commitments.remove(channel);
        }
        
        // Track this channel
        chat_context.add_channel(channel);
        
        // Save state
        let state_to_save = create_app_state(
            blocked_peers,
            channel_creators,
            &chat_context.active_channels,
            password_protected_channels,
            channel_key_commitments,
            encrypted_channel_passwords,
            nickname
        );
        if let Err(e) = save_state(&state_to_save) {
            eprintln!("Warning: Could not save state: {}", e);
        }
    }
}

// Handler for delivery ACK messages
async fn handle_delivery_ack_message(
    packet: &BitchatPacket,
    notification_value: &[u8],
    encryption_service: &EncryptionService,
    delivery_tracker: &mut DeliveryTracker,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
    my_peer_id: &str,
) {
    debug_println!("[<-- RECV] Delivery ACK from {}", packet.sender_id_str);
    
    // Check if this ACK is for us
    let is_for_us = packet.recipient_id_str.as_ref()
        .map(|r| r == my_peer_id)
        .unwrap_or(false);
    
    if is_for_us {
        // Decrypt the ACK payload if it's encrypted
        let ack_payload = if packet.ttl == 3 && encryption_service.has_peer_key(&packet.sender_id_str) {
            // ACKs might be encrypted for private messages
            match encryption_service.decrypt(&packet.payload, &packet.sender_id_str) {
                Ok(decrypted) => decrypted,
                Err(_) => packet.payload.clone() // Fall back to unencrypted
            }
        } else {
            packet.payload.clone()
        };
        
        // Parse the ACK JSON
        if let Ok(ack) = serde_json::from_slice::<DeliveryAck>(&ack_payload) {
            debug_println!("[ACK] Received ACK for message: {}", ack.original_message_id);
            debug_println!("[ACK] From: {} ({})", ack.recipient_nickname, ack.recipient_id);
            
            // Mark message as delivered
            if delivery_tracker.mark_delivered(&ack.original_message_id) {
                // Show delivery confirmation
                print!("\r\x1b[K\x1b[90m‚úì Delivered to {}\x1b[0m\n> ", ack.recipient_nickname);
                std::io::stdout().flush().unwrap();
            }
        } else {
            debug_println!("[ACK] Failed to parse delivery ACK");
        }
    } else if packet.ttl > 1 {
        // Relay ACK if not for us
        let mut relay_data = notification_value.to_vec();
        relay_data[2] = packet.ttl - 1;
        let _ = peripheral.write(cmd_char, &relay_data, WriteType::WithoutResponse).await;
    }
}

// Handler for delivery status request messages
fn handle_delivery_status_request_message(_packet: &BitchatPacket) {
    // iOS defines this but doesn't implement it yet
    debug_println!("[<-- RECV] Delivery status request (not implemented)");
}

// Handler for read receipt messages
fn handle_read_receipt_message(_packet: &BitchatPacket) {
    // iOS defines this but doesn't implement it yet
    debug_println!("[<-- RECV] Read receipt (not implemented)");
}

// Handler for /transfer command (transfer channel ownership)
async fn handle_transfer_command(
    line: &str,
    chat_context: &ChatContext,
    channel_creators: &mut HashMap<String, String>,
    password_protected_channels: &HashSet<String>,
    channel_keys: &HashMap<String, [u8; 32]>,
    blocked_peers: &HashSet<String>,
    create_app_state: &dyn Fn(&HashSet<String>, &HashMap<String, String>, &Vec<String>, &HashSet<String>, &HashMap<String, String>, &HashMap<String, persistence::EncryptedPassword>, &str) -> AppState,
    nickname: &str,
    my_peer_id: &str,
    peers: &Arc<Mutex<HashMap<String, Peer>>>,
    peripheral: &Peripheral,
    cmd_char: &btleplug::api::Characteristic,
) -> bool {
    if line.starts_with("/transfer ") {
        let parts: Vec<&str> = line.split_whitespace().collect();
        
        // Check if user is in a channel
        if let ChatMode::Channel(channel) = &chat_context.current_mode {
            // Check if user is the channel owner
            if let Some(owner_id) = channel_creators.get(channel) {
                if owner_id == &my_peer_id {
                    if parts.len() >= 2 {
                        let target_name = parts[1];
                        
                        // Remove @ prefix if present
                        let target_name = if target_name.starts_with('@') {
                            &target_name[1..]
                        } else {
                            target_name
                        };
                        
                        // Find the peer ID for the target nickname
                        let peers_lock = peers.lock().unwrap();
                        let target_peer_id = peers_lock.iter()
                            .find(|(_, peer)| peer.nickname.as_ref().map(|n| n == target_name).unwrap_or(false))
                            .map(|(id, _)| id.clone());
                        drop(peers_lock);
                        
                        if let Some(new_owner_id) = target_peer_id {
                            // Update the channel owner
                            channel_creators.insert(channel.clone(), new_owner_id.clone());
                            
                            // Save the updated state
                            let state_to_save = create_app_state(
                                blocked_peers,
                                channel_creators,
                                &Vec::new(), // Not persisting joined channels yet
                                password_protected_channels,
                                &HashMap::new(), // channel_key_commitments
                                &HashMap::new(), // app_state.encrypted_channel_passwords
                                nickname
                            );
                            if let Err(e) = save_state(&state_to_save) {
                                eprintln!("Failed to save state: {}", e);
                            }
                            
                            // Send channel announce to notify everyone
                            debug_println!("[CHANNEL] Transferring ownership of {} to {}", channel, target_name);
                            
                            // Check if channel is password protected to get key commitment
                            let is_protected = password_protected_channels.contains(channel);
                            
                            let key_commitment = if is_protected {
                                channel_keys.get(channel).map(|key| {
                                    let hash = sha2::Sha256::digest(key);
                                    hex::encode(hash)
                                })
                            } else {
                                None
                            };
                            
                            // Send announce packet with new owner
                            match send_channel_announce(&peripheral, &cmd_char, &new_owner_id, channel, is_protected, key_commitment.as_deref()).await {
                                Ok(_) => {
                                    println!("¬ª Transferred ownership of {} to {}", channel, target_name);
                                }
                                Err(e) => {
                                    eprintln!("Failed to send ownership transfer announcement: {}", e);
                                }
                            }
                        } else {
                            println!("\x1b[93m‚ö† User '{}' not found\x1b[0m", target_name);
                            println!("\x1b[90mMake sure they are online and you have the correct nickname.\x1b[0m");
                        }
                    } else {
                        println!("\x1b[93m‚ö† Usage: /transfer @<username>\x1b[0m");
                        println!("\x1b[90mExample: /transfer @newowner\x1b[0m");
                    }
                } else {
                    println!("¬ª Only the channel owner can transfer ownership.");
                }
            } else {
                println!("¬ª Only the channel owner can transfer ownership.");
            }
        } else {
            println!("¬ª You must be in a channel to use /transfer.");
        }
        return true;
    }
    false
}
